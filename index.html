<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Limb Blaster</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a2e;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100dvh;
}

#game-container {
  position: relative;
  flex: 1 1 0;
  min-height: 0;
  overflow: hidden;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#hud {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  display: flex;
  justify-content: space-between;
  color: #0ff;
  font-size: 16px;
  text-shadow: 0 0 8px #0ff;
  pointer-events: none;
  z-index: 10;
}

#input-display {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: #ff0;
  font-size: 28px;
  text-shadow: 0 0 12px #ff0;
  pointer-events: none;
  z-index: 10;
  min-height: 36px;
}

#onscreen-keyboard {
  display: none;
  background: #111;
  padding: 6px 6px calc(6px + env(safe-area-inset-bottom, 0px));
  gap: 5px;
  z-index: 20;
  flex-shrink: 0;
}

#onscreen-keyboard.visible {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
}

#onscreen-keyboard button {
  background: #1a1a4e;
  color: #0ff;
  border: 1px solid #0ff;
  border-radius: 8px;
  font-size: 20px;
  font-family: 'Courier New', monospace;
  padding: 10px 0;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.1s;
}

#onscreen-keyboard button:active {
  background: #0ff;
  color: #000;
}

#overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.8);
  z-index: 30;
}

#overlay.hidden { display: none; }

#overlay h1 {
  color: #0ff;
  font-size: 36px;
  text-shadow: 0 0 20px #0ff;
  margin-bottom: 8px;
}

#overlay .subtitle {
  color: #aaa;
  font-size: 14px;
  margin-bottom: 24px;
  text-align: center;
  padding: 0 20px;
  line-height: 1.5;
}

#overlay .final-score {
  color: #ff0;
  font-size: 22px;
  margin-bottom: 16px;
  text-shadow: 0 0 10px #ff0;
}

#overlay button {
  background: none;
  border: 2px solid #0ff;
  color: #0ff;
  font-family: 'Courier New', monospace;
  font-size: 20px;
  padding: 12px 32px;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.2s;
}

#overlay button:hover, #overlay button:active {
  background: #0ff;
  color: #000;
}
</style>
</head>
<body>

<div id="game-container">
  <canvas id="game"></canvas>
  <div id="hud">
    <span id="score-display">Score: 0</span>
    <span id="wave-display">Wave: 1</span>
    <span id="lives-display">Lives: 3</span>
  </div>
  <div id="input-display"></div>
  <div id="overlay">
    <h1>Limb Blaster</h1>
    <div class="subtitle">
      Alien creatures attack in formation!<br>
      Type the number of limbs to fire.<br><br>
      Spider=8 &bull; Octopus=8 &bull; Human=4<br>
      Bird=2 &bull; Fish=0 &bull; Insect=6
    </div>
    <div class="final-score" id="final-score"></div>
    <button id="start-btn">Start</button>
  </div>
</div>

<div id="onscreen-keyboard">
  <button data-key="0">0</button>
  <button data-key="1">1</button>
  <button data-key="2">2</button>
  <button data-key="3">3</button>
  <button data-key="4">4</button>
  <button data-key="5">5</button>
  <button data-key="6">6</button>
  <button data-key="7">7</button>
  <button data-key="8">8</button>
  <button data-key="9">9</button>
</div>

<script>
// --- Constants ---
const MISSILE_SPEED = 6;
const PLAYER_LIVES = 3;
const STAR_COUNT = 120;

// Formation constants
const FORMATION_CELL_W = 52;
const FORMATION_CELL_H = 48;
const FORMATION_TOP_MARGIN = 50;
const FORMATION_H_SPEED_BASE = 0.3;
const FORMATION_H_SPEED_WAVE = 0.04;

// Dive attack constants
const DIVE_SPEED_BASE = 0.4;
const DIVE_SPEED_WAVE = 0.03;
const DIVE_INTERVAL_BASE = 4500;
const DIVE_INTERVAL_MIN = 1500;
const DIVE_INTERVAL_WAVE_REDUCTION = 150;

// --- Canvas setup ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

function resize() {
  canvas.width = container.clientWidth * devicePixelRatio;
  canvas.height = container.clientHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const W = () => container.clientWidth;
const H = () => container.clientHeight;

// --- Detect mobile ---
const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
if (isMobile) {
  document.getElementById('onscreen-keyboard').classList.add('visible');
}

// --- Game state ---
let enemies = [];
let missiles = [];
let particles = [];
let stars = [];
let score = 0;
let wave = 1;
let lives = PLAYER_LIVES;
let gameRunning = false;
let inputBuffer = '';
let lastTime = 0;
let playerX = 0;
let playerY = 0;
let playerTargetX = null;  // for touch-to-move (null = no touch active)
const keysDown = new Set();
const PLAYER_SPEED = 4;    // pixels per frame at 60fps

// Formation state
let formationX = 0;        // center X offset of the formation
let formationDir = 1;       // 1 = right, -1 = left
let formationSpeed = 0;
let formationCols = 0;      // actual columns in current wave
let formationRows = 0;      // actual rows in current wave

// Dive state
let diveTimer = 0;
let waveTransition = 0;
let waveCleared = false;

// Entry animation state
let entryQueue = [];        // enemies waiting to fly in
let entryActive = [];       // enemies currently flying to their slot

// --- Stars background ---
function initStars() {
  stars = [];
  for (let i = 0; i < STAR_COUNT; i++) {
    stars.push({
      x: Math.random() * 1000,
      y: Math.random() * 1000,
      size: Math.random() * 1.5 + 0.5,
      speed: Math.random() * 0.3 + 0.1,
      brightness: Math.random()
    });
  }
}
initStars();

// --- Enemy types ---
const ENEMY_TYPES = [
  {
    name: 'Fish', limbs: 0, color: '#4488ff', width: 44, height: 22,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y);
      ctx.lineTo(x + w / 2 + 10, y - 8);
      ctx.lineTo(x + w / 2 + 10, y + 8);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - w / 4, y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x - w / 4, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Bird', limbs: 2, color: '#ff6644', width: 40, height: 28,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y, w / 3, h / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      const wingFlap = Math.sin(t * 8) * 6;
      ctx.beginPath();
      ctx.moveTo(x - 5, y);
      ctx.lineTo(x - w / 2 - 4, y - 10 + wingFlap);
      ctx.lineTo(x - w / 4, y + 2);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x + 5, y);
      ctx.lineTo(x + w / 2 + 4, y - 10 + wingFlap);
      ctx.lineTo(x + w / 4, y + 2);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x - 4, y + h / 3);
      ctx.lineTo(x - 6, y + h / 2 + 4);
      ctx.moveTo(x + 4, y + h / 3);
      ctx.lineTo(x + 6, y + h / 2 + 4);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x, y - 3, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x, y - 3, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Human', limbs: 4, color: '#ffaa33', width: 28, height: 44,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(x, y - h / 3, 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x, y - h / 3 + 7);
      ctx.lineTo(x, y + 4);
      ctx.stroke();
      const armSwing = Math.sin(t * 4) * 8;
      ctx.beginPath();
      ctx.moveTo(x, y - h / 6);
      ctx.lineTo(x - 12, y - h / 6 + 10 + armSwing);
      ctx.moveTo(x, y - h / 6);
      ctx.lineTo(x + 12, y - h / 6 + 10 - armSwing);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y + 4);
      ctx.lineTo(x - 8, y + h / 2.5);
      ctx.moveTo(x, y + 4);
      ctx.lineTo(x + 8, y + h / 2.5);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 2.5, y - h / 3 - 1, 1.5, 0, Math.PI * 2);
      ctx.arc(x + 2.5, y - h / 3 - 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Insect', limbs: 6, color: '#66ff44', width: 32, height: 24,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x - 6, y, 6, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 4, y, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      const legWiggle = Math.sin(t * 10) * 3;
      for (let i = 0; i < 3; i++) {
        const lx = x - 4 + i * 6;
        ctx.beginPath();
        ctx.moveTo(lx, y + 4);
        ctx.lineTo(lx - 6, y + 12 + (i % 2 === 0 ? legWiggle : -legWiggle));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx, y + 4);
        ctx.lineTo(lx + 6, y + 12 + (i % 2 === 0 ? -legWiggle : legWiggle));
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.moveTo(x - 8, y - 4);
      ctx.lineTo(x - 14, y - 12);
      ctx.moveTo(x - 4, y - 4);
      ctx.lineTo(x - 8, y - 14);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 9, y - 2, 2, 0, Math.PI * 2);
      ctx.arc(x - 4, y - 2, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Spider', limbs: 8, color: '#cc44ff', width: 38, height: 34,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x, y + 8, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      const legAnim = Math.sin(t * 8) * 4;
      for (let i = 0; i < 4; i++) {
        const angle = (-0.8 + i * 0.45);
        const knee = 12;
        const lkx = x - Math.cos(angle) * knee;
        const lky = y + Math.sin(angle) * knee + (i % 2 === 0 ? legAnim : -legAnim);
        ctx.beginPath();
        ctx.moveTo(x - 4, y - 2 + i * 4);
        ctx.lineTo(lkx - 4, lky);
        ctx.lineTo(lkx - 8, lky + 8);
        ctx.stroke();
        const rkx = x + Math.cos(angle) * knee;
        const rky = y + Math.sin(angle) * knee + (i % 2 === 0 ? -legAnim : legAnim);
        ctx.beginPath();
        ctx.moveTo(x + 4, y - 2 + i * 4);
        ctx.lineTo(rkx + 4, rky);
        ctx.lineTo(rkx + 8, rky + 8);
        ctx.stroke();
      }
      ctx.fillStyle = '#f44';
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(x - 4 + (i % 2) * 8, y - 4 + Math.floor(i / 2) * 4, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  },
  {
    name: 'Octopus', limbs: 8, color: '#ff44aa', width: 40, height: 42,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y - 6, 14, 12, 0, Math.PI, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x, y - 2, 14, 6, 0, 0, Math.PI);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      for (let i = 0; i < 8; i++) {
        const baseX = x - 12 + i * 3.4;
        const tentLen = 16;
        const wv = Math.sin(t * 4 + i * 0.8) * 5;
        const wv2 = Math.cos(t * 3 + i * 1.2) * 3;
        ctx.beginPath();
        ctx.moveTo(baseX, y + 2);
        ctx.quadraticCurveTo(baseX + wv, y + 10, baseX + wv2, y + tentLen + 4);
        ctx.stroke();
      }
      ctx.lineCap = 'butt';
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x - 5, y - 6, 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 5, y - 6, 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x - 5, y - 5, 2, 0, Math.PI * 2);
      ctx.arc(x + 5, y - 5, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
];

// --- Player ship ---
function updatePlayer(dt) {
  playerY = H() - 40;

  // Keyboard movement
  let moveDir = 0;
  if (keysDown.has('ArrowLeft'))  moveDir -= 1;
  if (keysDown.has('ArrowRight')) moveDir += 1;

  if (moveDir !== 0) {
    playerX += moveDir * PLAYER_SPEED * dt * 60;
    playerTargetX = null; // keyboard overrides touch
  }

  // Touch-to-move: glide toward tap position
  if (playerTargetX !== null) {
    const dx = playerTargetX - playerX;
    if (Math.abs(dx) < 2) {
      playerX = playerTargetX;
      playerTargetX = null;
    } else {
      playerX += Math.sign(dx) * Math.min(Math.abs(dx), PLAYER_SPEED * 1.5 * dt * 60);
    }
  }

  // Clamp to screen bounds
  const margin = 16;
  playerX = Math.max(margin, Math.min(W() - margin, playerX));
}

function drawPlayer(t) {
  const px = playerX;

  ctx.fillStyle = '#0ff';
  ctx.beginPath();
  ctx.moveTo(px, playerY - 16);
  ctx.lineTo(px - 14, playerY + 10);
  ctx.lineTo(px + 14, playerY + 10);
  ctx.closePath();
  ctx.fill();

  const flicker = Math.sin(t * 20) * 2;
  ctx.fillStyle = `rgba(0, 255, 255, 0.4)`;
  ctx.beginPath();
  ctx.moveTo(px - 6, playerY + 10);
  ctx.lineTo(px, playerY + 18 + flicker);
  ctx.lineTo(px + 6, playerY + 10);
  ctx.closePath();
  ctx.fill();
}

// --- Formation helpers ---

// Get the world position of a formation slot
function getFormationSlotPos(row, col) {
  const cellW = Math.min(FORMATION_CELL_W, (W() - 40) / Math.max(formationCols, 1));
  const totalW = formationCols * cellW;
  const centerX = W() / 2 + formationX;
  const startX = centerX - totalW / 2;
  const x = startX + col * cellW + cellW / 2;
  const y = FORMATION_TOP_MARGIN + row * FORMATION_CELL_H + FORMATION_CELL_H / 2;
  return { x, y };
}

// Build the enemy grid for a wave
function buildFormation() {
  enemies = [];
  entryQueue = [];
  entryActive = [];

  // Determine how many rows/cols to fill based on wave
  const rows = Math.min(4, 2 + Math.floor(wave / 2));
  const cols = Math.min(8, 4 + Math.min(4, wave));
  formationRows = rows;
  formationCols = cols;

  // Pick enemy types for each row (variety increases with wave)
  const availableTypes = ENEMY_TYPES.slice();

  // Build the formation - queue them for entry animation
  for (let r = 0; r < rows; r++) {
    const rowType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
    for (let c = 0; c < cols; c++) {
      let type = rowType;
      if (Math.random() < 0.25) {
        type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      }

      const enemy = {
        row: r,
        col: c,
        type,
        hit: false,
        flash: 0,
        removeTimer: undefined,
        state: 'entering',
        diveX: 0,
        diveY: 0,
        divePhase: 0,
        diveStartX: 0,
        diveStartY: 0,
        spawnTime: performance.now() / 1000,
        entryX: 0,
        entryY: -40,
        entryProgress: 0,
      };
      entryQueue.push(enemy);
    }
  }

  // Stagger the entry - groups fly in from top
  entryQueue.sort((a, b) => a.row !== b.row ? a.row - b.row : a.col - b.col);

  // Reset formation position
  formationX = 0;
  formationDir = 1;
  formationSpeed = FORMATION_H_SPEED_BASE + wave * FORMATION_H_SPEED_WAVE;
  diveTimer = 3000; // grace period before first dive
  waveCleared = false;
}

// Launch next batch from entry queue
let entryBatchTimer = 0;
const ENTRY_BATCH_SIZE = 4;
const ENTRY_BATCH_DELAY = 300; // ms between batches

function updateEntryQueue(dt) {
  // Launch batches from the queue
  entryBatchTimer -= dt * 1000;
  if (entryBatchTimer <= 0 && entryQueue.length > 0) {
    const batch = entryQueue.splice(0, ENTRY_BATCH_SIZE);
    for (const e of batch) {
      // Start from top of screen, slightly spread
      const targetPos = getFormationSlotPos(e.row, e.col);
      e.entryX = W() / 2 + (Math.random() - 0.5) * 100;
      e.entryY = -30 - Math.random() * 40;
      e.entryProgress = 0;
      entryActive.push(e);
      enemies.push(e);
    }
    entryBatchTimer = ENTRY_BATCH_DELAY;
  }

  // Animate active entries
  for (let i = entryActive.length - 1; i >= 0; i--) {
    const e = entryActive[i];
    e.entryProgress += dt * 2.5; // speed of entry animation
    if (e.entryProgress >= 1) {
      e.entryProgress = 1;
      e.state = 'formation';
      entryActive.splice(i, 1);
    }
  }
}

// --- Formation movement ---
function updateFormation(dt) {
  // Move the formation side to side
  formationX += formationSpeed * formationDir * dt * 60;

  // Compute actual bounds from living formation/entering enemies
  let minX = Infinity, maxX = -Infinity;
  for (const e of enemies) {
    if (e.hit || (e.state !== 'formation' && e.state !== 'entering')) continue;
    const pos = getFormationSlotPos(e.row, e.col);
    const hw = (e.type.width / 2) + 8;
    minX = Math.min(minX, pos.x - hw);
    maxX = Math.max(maxX, pos.x + hw);
  }

  if (minX === Infinity) return; // no formation enemies

  const margin = 8;
  if (maxX > W() - margin && formationDir > 0) {
    formationDir = -1;
    formationX -= (maxX - (W() - margin)); // snap back in-bounds
  } else if (minX < margin && formationDir < 0) {
    formationDir = 1;
    formationX += (margin - minX); // snap back in-bounds
  }
}

// --- Dive attacks ---
function updateDiveAttacks(dt) {
  diveTimer -= dt * 1000;

  const formationEnemies = enemies.filter(e => !e.hit && e.state === 'formation');
  if (formationEnemies.length === 0) return;

  if (diveTimer <= 0) {
    // Pick a random formation enemy to dive
    const diver = formationEnemies[Math.floor(Math.random() * formationEnemies.length)];
    const pos = getFormationSlotPos(diver.row, diver.col);

    diver.state = 'diving';
    diver.divePhase = 0;
    diver.diveStartX = pos.x;
    diver.diveStartY = pos.y;
    // Aim toward player with some randomness
    diver.diveTargetX = W() / 2 + (Math.random() - 0.5) * W() * 0.6;
    diver.diveTargetY = H() + 60;

    const interval = Math.max(DIVE_INTERVAL_MIN,
      DIVE_INTERVAL_BASE - wave * DIVE_INTERVAL_WAVE_REDUCTION);
    diveTimer = interval + Math.random() * 800;
  }
}

function updateDivingEnemies(dt) {
  if (!gameRunning) return;
  const diveSpeed = DIVE_SPEED_BASE + wave * DIVE_SPEED_WAVE;

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.state !== 'diving' && e.state !== 'returning') continue;
    if (e.hit) continue;

    if (e.state === 'diving') {
      e.divePhase += dt * diveSpeed;

      // Swooping curve path
      const t = e.divePhase;
      const wobble = Math.sin(t * 4) * 30;

      // Interpolate with curve
      e.diveX = e.diveStartX + (e.diveTargetX - e.diveStartX) * t + wobble;
      e.diveY = e.diveStartY + (e.diveTargetY - e.diveStartY) * t;

      if (e.divePhase >= 1) {
        // Reached bottom - lose a life
        lives--;
        updateHUD();
        screenShake(8, 0.3);
        if (lives <= 0) {
          gameOver();
          return;
        }
        // Start returning to formation
        e.state = 'returning';
        e.divePhase = 0;
        const target = getFormationSlotPos(e.row, e.col);
        e.diveStartX = e.diveX;
        e.diveStartY = -40; // come back from top
        e.diveTargetX = target.x;
        e.diveTargetY = target.y;
      }
    } else if (e.state === 'returning') {
      e.divePhase += dt * 2.0;
      const t = Math.min(1, e.divePhase);

      // Smooth return arc from top
      const target = getFormationSlotPos(e.row, e.col);
      e.diveX = e.diveStartX + (target.x - e.diveStartX) * t;
      e.diveY = e.diveStartY + (target.y - e.diveStartY) * t;

      if (e.divePhase >= 1) {
        e.state = 'formation';
      }
    }
  }
}

// --- Get world position for any enemy ---
function getEnemyPos(e) {
  if (e.state === 'entering') {
    const target = getFormationSlotPos(e.row, e.col);
    const t = e.entryProgress;
    // Ease-out curve
    const ease = 1 - (1 - t) * (1 - t);
    return {
      x: e.entryX + (target.x - e.entryX) * ease,
      y: e.entryY + (target.y - e.entryY) * ease
    };
  } else if (e.state === 'formation') {
    return getFormationSlotPos(e.row, e.col);
  } else if (e.state === 'diving' || e.state === 'returning') {
    return { x: e.diveX, y: e.diveY };
  }
  return getFormationSlotPos(e.row, e.col);
}

// --- Enemy update ---
function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.hit) {
      if (e.removeTimer !== undefined) {
        e.removeTimer -= dt;
        if (e.removeTimer <= 0) {
          enemies.splice(i, 1);
        }
      }
      continue;
    }
    if (e.flash > 0) e.flash -= dt * 4;
  }
}

function drawEnemies(t) {
  for (const e of enemies) {
    if (e.hit) continue;
    const pos = getEnemyPos(e);
    ctx.save();
    if (e.flash > 0) {
      ctx.globalAlpha = 0.5 + 0.5 * Math.sin(e.flash * 20);
    }
    // Slight visual indication of diving enemies
    if (e.state === 'diving') {
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 10;
    }
    e.type.draw(pos.x, pos.y, e.type.width, e.type.height, t);

    // Limb count label
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(e.type.limbs, pos.x, pos.y - e.type.height / 2 - 6);
    ctx.restore();
  }
}

// --- Missiles ---
function fireMissile(targetLimbs) {
  const matching = enemies
    .filter(e => e.type.limbs === targetLimbs && !e.hit)
    .map(e => ({ enemy: e, pos: getEnemyPos(e) }))
    .sort((a, b) => b.pos.y - a.pos.y);

  if (matching.length === 0) return false;

  const target = matching[0].enemy;
  const px = playerX;

  missiles.push({
    x: px, y: playerY - 16,
    target,
    trail: [],
    alive: true
  });

  return true;
}

function updateMissiles(dt) {
  for (let i = missiles.length - 1; i >= 0; i--) {
    const m = missiles[i];
    if (!m.alive) { missiles.splice(i, 1); continue; }

    const t = m.target;
    if (t.hit || enemies.indexOf(t) === -1) {
      m.y -= MISSILE_SPEED * dt * 60;
      // Decay orphaned trail points
      for (let j = m.trail.length - 1; j >= 0; j--) {
        m.trail[j].life -= 0.05;
        if (m.trail[j].life <= 0) m.trail.splice(j, 1);
      }
      if (m.y < -20) { missiles.splice(i, 1); }
      continue;
    }

    const tpos = getEnemyPos(t);
    const dx = tpos.x - m.x;
    const dy = tpos.y - m.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 14) {
      t.hit = true;
      t.removeTimer = 0.05;
      m.alive = false;
      spawnExplosion(tpos.x, tpos.y, t.type.color);
      score += 10 + wave * 5;
      // Bonus for hitting a diving enemy
      if (t.state === 'diving') {
        score += 20;
      }
      updateHUD();
      missiles.splice(i, 1);
      continue;
    }

    const speed = MISSILE_SPEED * dt * 60;
    m.x += (dx / dist) * speed;
    m.y += (dy / dist) * speed;

    m.trail.push({ x: m.x, y: m.y, life: 1 });
    if (m.trail.length > 20) m.trail.shift();

    // Decay trail life and remove expired points
    for (let j = m.trail.length - 1; j >= 0; j--) {
      m.trail[j].life -= 0.05;
      if (m.trail[j].life <= 0) m.trail.splice(j, 1);
    }
  }
}

function drawMissiles() {
  for (const m of missiles) {
    for (let i = 0; i < m.trail.length; i++) {
      const p = m.trail[i];
      ctx.fillStyle = `rgba(255, 255, 0, ${Math.max(0, p.life) * 0.6})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0, 2 * p.life), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = '#ff0';
    ctx.shadowColor = '#ff0';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// --- Particles / Explosions ---
function spawnExplosion(x, y, color) {
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 3 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      color,
      size: Math.random() * 3 + 1
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, Math.max(0, p.size * p.life), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Starfield ---
function drawStars(dt) {
  for (const s of stars) {
    s.y += s.speed * dt * 60;
    if (s.y > 1000) { s.y = 0; s.x = Math.random() * 1000; }
    s.brightness += (Math.random() - 0.5) * 0.1;
    s.brightness = Math.max(0.2, Math.min(1, s.brightness));

    const sx = (s.x / 1000) * W();
    const sy = (s.y / 1000) * H();
    ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness * 0.7})`;
    ctx.beginPath();
    ctx.arc(sx, sy, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- Screen shake ---
let shakeAmount = 0;
let shakeDuration = 0;
function screenShake(amount, duration) {
  shakeAmount = amount;
  shakeDuration = duration;
}

// --- Wave management ---
function checkWave() {
  if (waveCleared) return;

  const alive = enemies.filter(e => !e.hit);
  if (alive.length === 0 && entryQueue.length === 0 && entryActive.length === 0) {
    waveCleared = true;
    wave++;
    waveTransition = 2.5;
    updateHUD();
    // Build next formation after a brief delay
    setTimeout(() => {
      if (gameRunning) {
        buildFormation();
      }
    }, 1500);
  }
}

// --- HUD ---
function updateHUD() {
  document.getElementById('score-display').textContent = `Score: ${score}`;
  document.getElementById('wave-display').textContent = `Wave: ${wave}`;
  document.getElementById('lives-display').textContent = `Lives: ${'â™¥'.repeat(Math.max(0, lives))}`;
}

// --- Input handling ---
function handleDigit(digit) {
  if (!gameRunning) return;

  const num = parseInt(digit);
  if (isNaN(num)) return;

  inputBuffer = digit;
  document.getElementById('input-display').textContent = digit;

  const hit = fireMissile(num);

  const display = document.getElementById('input-display');
  display.style.color = hit ? '#0f0' : '#f44';
  setTimeout(() => {
    inputBuffer = '';
    display.textContent = '';
    display.style.color = '#ff0';
  }, 300);
}

// Desktop keyboard
document.addEventListener('keydown', (e) => {
  if (e.key >= '0' && e.key <= '9') {
    handleDigit(e.key);
  }
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
    e.preventDefault();
    keysDown.add(e.key);
  }
});
document.addEventListener('keyup', (e) => {
  keysDown.delete(e.key);
});

// Touch/click to move ship on the game canvas
canvas.addEventListener('touchstart', (e) => {
  if (!gameRunning) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  playerTargetX = (e.touches[0].clientX - rect.left) / scaleX;
});
canvas.addEventListener('touchmove', (e) => {
  if (!gameRunning) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  playerTargetX = (e.touches[0].clientX - rect.left) / scaleX;
});
canvas.addEventListener('touchend', () => {
  // Keep gliding to last target, don't snap-clear
});
canvas.addEventListener('mousedown', (e) => {
  if (!gameRunning) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  playerTargetX = (e.clientX - rect.left) / scaleX;
});

// Mobile on-screen keyboard
document.querySelectorAll('#onscreen-keyboard button').forEach(btn => {
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleDigit(btn.dataset.key);
  });
  btn.addEventListener('mousedown', (e) => {
    e.preventDefault();
    handleDigit(btn.dataset.key);
  });
});

// --- Game loop ---
function gameLoop(timestamp) {
  if (!gameRunning) return;

  try {
    const t = timestamp / 1000;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    // Update
    updatePlayer(dt);
    updateEntryQueue(dt);
    updateFormation(dt);
    updateDiveAttacks(dt);
    updateDivingEnemies(dt);
    updateEnemies(dt);
    updateMissiles(dt);
    updateParticles(dt);
    checkWave();

    // Screen shake
    let shakeX = 0, shakeY = 0;
    if (shakeDuration > 0) {
      shakeDuration -= dt;
      shakeX = (Math.random() - 0.5) * shakeAmount * 2;
      shakeY = (Math.random() - 0.5) * shakeAmount * 2;
      shakeAmount *= 0.95;
    }

    // Wave transition text
    if (waveTransition > 0) {
      waveTransition -= dt;
    }

    // Draw
    ctx.save();
    ctx.translate(shakeX, shakeY);

    ctx.fillStyle = '#0a0a2e';
    ctx.fillRect(-10, -10, W() + 20, H() + 20);

    drawStars(dt);
    drawEnemies(t);
    drawMissiles();
    drawParticles();
    drawPlayer(t);

    // Wave transition overlay
    if (waveTransition > 0) {
      const alpha = Math.min(1, waveTransition);
      ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
      ctx.font = 'bold 28px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`Wave ${wave}`, W() / 2, H() / 2);
      ctx.font = '16px Courier New';
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
      ctx.fillText('Get ready!', W() / 2, H() / 2 + 30);
    }

    ctx.restore();
  } catch (err) {
    console.error('Game loop error:', err);
  }

  requestAnimationFrame(gameLoop);
}

// --- Start / Restart ---
function startGame() {
  enemies = [];
  missiles = [];
  particles = [];
  entryQueue = [];
  entryActive = [];
  score = 0;
  wave = 1;
  lives = PLAYER_LIVES;
  inputBuffer = '';
  gameRunning = true;
  playerX = W() / 2;
  playerTargetX = null;
  keysDown.clear();
  waveTransition = 2.5;
  entryBatchTimer = 0;
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('input-display').textContent = '';
  document.getElementById('final-score').textContent = '';
  updateHUD();
  lastTime = performance.now();
  buildFormation();
  requestAnimationFrame(gameLoop);
}

function gameOver() {
  gameRunning = false;
  const overlay = document.getElementById('overlay');
  overlay.querySelector('h1').textContent = 'Game Over';
  document.getElementById('final-score').textContent = `Final Score: ${score}`;
  document.getElementById('start-btn').textContent = 'Retry';
  overlay.classList.remove('hidden');
}

// --- Start button ---
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('start-btn').addEventListener('touchend', (e) => {
  e.preventDefault();
  startGame();
});

// Initial HUD
updateHUD();
</script>
</body>
</html>
