<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Mathgala</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }

body {
  background: #0a0a2e;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  touch-action: none;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  display: flex;
  flex-direction: column;
  height: 100vh;
  height: 100dvh;
}

#game-container {
  position: relative;
  flex: 1 1 0;
  min-height: 0;
  overflow: hidden;
}

canvas {
  display: block;
  width: 100%;
  height: 100%;
}

#hud {
  position: absolute;
  top: 10px;
  left: 10px;
  right: 10px;
  display: flex;
  justify-content: space-between;
  color: #0ff;
  font-size: 16px;
  text-shadow: 0 0 8px #0ff;
  pointer-events: none;
  z-index: 10;
}

#input-display {
  position: absolute;
  bottom: 10px;
  left: 50%;
  transform: translateX(-50%);
  color: #ff0;
  font-size: 28px;
  text-shadow: 0 0 12px #ff0;
  pointer-events: none;
  z-index: 10;
  min-height: 36px;
}

#onscreen-keyboard {
  display: none;
  background: #111;
  padding: 6px 6px calc(6px + env(safe-area-inset-bottom, 0px));
  gap: 5px;
  z-index: 20;
  flex-shrink: 0;
}

#onscreen-keyboard.visible {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
}

#onscreen-keyboard button {
  background: #1a1a4e;
  color: #0ff;
  border: 1px solid #0ff;
  border-radius: 8px;
  font-size: 20px;
  font-family: 'Courier New', monospace;
  padding: 10px 0;
  cursor: pointer;
  -webkit-tap-highlight-color: transparent;
  transition: background 0.1s;
}

#onscreen-keyboard button:active {
  background: #0ff;
  color: #000;
}

#overlay {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.8);
  z-index: 30;
}

#overlay.hidden { display: none; }

#overlay h1 {
  font-family: 'Press Start 2P', monospace;
  font-size: 36px;
  font-style: italic;
  color: #0ff;
  text-shadow:
    3px 3px 0 #066,
    0 0 20px #0ff,
    0 0 40px #0af,
    0 0 80px rgba(0,255,255,0.3);
  margin-bottom: 16px;
  letter-spacing: 4px;
}

#overlay .subtitle {
  color: #aaa;
  font-size: 14px;
  margin-bottom: 24px;
  text-align: center;
  padding: 0 20px;
  line-height: 1.5;
}

#overlay .final-score {
  color: #ff0;
  font-size: 22px;
  margin-bottom: 16px;
  text-shadow: 0 0 10px #ff0;
}

#overlay button {
  background: none;
  border: 2px solid #0ff;
  color: #0ff;
  font-family: 'Courier New', monospace;
  font-size: 20px;
  padding: 12px 32px;
  cursor: pointer;
  border-radius: 6px;
  transition: background 0.2s;
}

#overlay button:hover, #overlay button:active {
  background: #0ff;
  color: #000;
}
</style>
</head>
<body>

<div id="game-container">
  <canvas id="game"></canvas>
  <div id="hud">
    <span id="score-display">Score: 0</span>
    <span id="wave-display">Wave: 1</span>
    <span id="lives-display">Lives: 3</span>
  </div>
  <div id="input-display"></div>
  <div id="overlay">
    <h1>Mathgala</h1>
    <div class="subtitle">
      Alien creatures attack in formation!<br>
      Type the number of limbs to fire.<br><br>
      Spider=8 &bull; Octopus=8 &bull; Human=4<br>
      Bird=2 &bull; Fish=0 &bull; Insect=6
    </div>
    <div class="final-score" id="final-score"></div>
    <button id="start-btn">Start</button>
  </div>
</div>

<div id="onscreen-keyboard">
  <button data-key="0">0</button>
  <button data-key="1">1</button>
  <button data-key="2">2</button>
  <button data-key="3">3</button>
  <button data-key="4">4</button>
  <button data-key="5">5</button>
  <button data-key="6">6</button>
  <button data-key="7">7</button>
  <button data-key="8">8</button>
  <button data-key="9">9</button>
</div>

<script>
// --- Constants ---
const MISSILE_SPEED = 6;
const PLAYER_LIVES = 5;
const STAR_COUNT = 120;

// Formation constants
const FORMATION_CELL_W = 52;
const FORMATION_CELL_H = 48;
const FORMATION_TOP_MARGIN = 50;
const FORMATION_H_SPEED_BASE = 0.08;
const FORMATION_H_SPEED_WAVE = 0.012;

// Dive attack constants
const DIVE_SPEED_BASE = 0.12;
const DIVE_SPEED_WAVE = 0.008;
const DIVE_INTERVAL_BASE = 5500;
const DIVE_INTERVAL_MIN = 2000;
const DIVE_INTERVAL_WAVE_REDUCTION = 120;

// --- Canvas setup ---
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const container = document.getElementById('game-container');

function resize() {
  canvas.width = container.clientWidth * devicePixelRatio;
  canvas.height = container.clientHeight * devicePixelRatio;
  ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
}
resize();
window.addEventListener('resize', resize);

const W = () => container.clientWidth;
const H = () => container.clientHeight;

// --- Detect mobile ---
const isMobile = ('ontouchstart' in window) || navigator.maxTouchPoints > 0;
if (isMobile) {
  document.getElementById('onscreen-keyboard').classList.add('visible');
}

// --- Game state ---
let enemies = [];
let missiles = [];
let particles = [];
let stars = [];
let bgObjects = [];
let score = 0;
let wave = 1;
let lives = PLAYER_LIVES;
let gameRunning = false;
let inputBuffer = '';
let lastTime = 0;
let playerX = 0;
let playerY = 0;
let playerTargetX = null;  // for touch-to-move (null = no touch active)
let playerTargetY = null;
const keysDown = new Set();
const PLAYER_SPEED = 4;    // pixels per frame at 60fps

// Formation state
let formationX = 0;        // center X offset of the formation
let formationDir = 1;       // 1 = right, -1 = left
let formationSpeed = 0;
let formationCols = 0;      // actual columns in current wave
let formationRows = 0;      // actual rows in current wave

// Dive state
let diveTimer = 0;
let waveTransition = 0;
let waveCleared = false;

// Entry animation state
let entryQueue = [];        // enemies waiting to fly in
let entryActive = [];       // enemies currently flying to their slot

// --- Stars background ---
function initStars() {
  stars = [];
  for (let i = 0; i < STAR_COUNT; i++) {
    // Assign to one of three depth layers
    const layer = Math.random();
    let depth, size, speed, brightness;
    if (layer < 0.5) {
      // Far stars: tiny, slow, dim (50% of stars)
      depth = 0;
      size = 0.4 + Math.random() * 0.4;
      speed = 0.03 + Math.random() * 0.04;
      brightness = 0.15 + Math.random() * 0.2;
    } else if (layer < 0.82) {
      // Mid stars (32%)
      depth = 1;
      size = 0.8 + Math.random() * 0.7;
      speed = 0.15 + Math.random() * 0.15;
      brightness = 0.35 + Math.random() * 0.3;
    } else {
      // Near stars: bigger, fast, bright (18%)
      depth = 2;
      size = 1.4 + Math.random() * 1.2;
      speed = 0.4 + Math.random() * 0.4;
      brightness = 0.7 + Math.random() * 0.3;
    }
    stars.push({
      x: Math.random() * 1000,
      y: Math.random() * 1000,
      size, speed, brightness, depth
    });
  }
}
initStars();

// --- Background space objects ---
// Weighted spawn table: comets are rare
const BG_OBJECT_WEIGHTS = [
  { kind: 'planet',   weight: 35 },
  { kind: 'nebula',   weight: 30 },
  { kind: 'asteroid', weight: 28 },
  { kind: 'comet',    weight: 7 },
];
const BG_TOTAL_WEIGHT = BG_OBJECT_WEIGHTS.reduce((s, w) => s + w.weight, 0);
function pickBgKind() {
  let r = Math.random() * BG_TOTAL_WEIGHT;
  for (const w of BG_OBJECT_WEIGHTS) {
    r -= w.weight;
    if (r <= 0) return w.kind;
  }
  return 'planet';
}

const BG_SPAWN_INTERVAL = 8000;
let bgSpawnTimer = 3000;

function spawnBgObject(startOffscreen) {
  const kind = pickBgKind();
  const obj = {
    kind,
    x: Math.random() * 1000,
    y: startOffscreen ? -100 : Math.random() * 1000,
    speed: 0.04 + Math.random() * 0.06,
    opacity: 0.12 + Math.random() * 0.15,
    seed: Math.random() * 1000
  };
  if (kind === 'planet') {
    obj.radius = 18 + Math.random() * 30;
    obj.color1 = ['#664422', '#886644', '#446688', '#668844', '#884466'][Math.floor(Math.random() * 5)];
    obj.color2 = ['#332211', '#443322', '#223344', '#334422', '#442233'][Math.floor(Math.random() * 5)];
    obj.hasRing = Math.random() > 0.6;
  } else if (kind === 'nebula') {
    obj.radius = 40 + Math.random() * 60;
    obj.hue = Math.floor(Math.random() * 360);
  } else if (kind === 'asteroid') {
    obj.radius = 4 + Math.random() * 8;
    obj.speed = 0.08 + Math.random() * 0.1;
    obj.rotation = Math.random() * Math.PI * 2;
    obj.rotSpeed = (Math.random() - 0.5) * 2;
    obj.points = [];
    const n = 6 + Math.floor(Math.random() * 4);
    for (let i = 0; i < n; i++) {
      obj.points.push(0.7 + Math.random() * 0.3);
    }
  } else if (kind === 'comet') {
    obj.radius = 3 + Math.random() * 3;
    obj.speed = 0.15 + Math.random() * 0.1;
    obj.tailLen = 40 + Math.random() * 60;
    obj.angle = 0.3 + Math.random() * 0.4; // slight diagonal
  }
  bgObjects.push(obj);
}

// Seed a couple on init
for (let i = 0; i < 3; i++) spawnBgObject(false);

function updateBgObjects(dt) {
  bgSpawnTimer -= dt * 1000;
  if (bgSpawnTimer <= 0 && bgObjects.length < 6) {
    spawnBgObject(true);
    bgSpawnTimer = BG_SPAWN_INTERVAL + Math.random() * 4000;
  }
  for (let i = bgObjects.length - 1; i >= 0; i--) {
    const o = bgObjects[i];
    o.y += o.speed * dt * 60;
    if (o.kind === 'asteroid') o.rotation += o.rotSpeed * dt;
    if (o.y > 1100) bgObjects.splice(i, 1);
  }
}

function drawBgObjects(t) {
  ctx.save();
  for (const o of bgObjects) {
    const sx = (o.x / 1000) * W();
    const sy = (o.y / 1000) * H();
    ctx.globalAlpha = o.opacity;

    if (o.kind === 'planet') {
      // Planet body with gradient
      const grad = ctx.createRadialGradient(sx - o.radius * 0.3, sy - o.radius * 0.3, o.radius * 0.1, sx, sy, o.radius);
      grad.addColorStop(0, o.color1);
      grad.addColorStop(1, o.color2);
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(sx, sy, o.radius, 0, Math.PI * 2);
      ctx.fill();
      // Optional ring
      if (o.hasRing) {
        ctx.strokeStyle = o.color1;
        ctx.lineWidth = 2;
        ctx.globalAlpha = o.opacity * 0.6;
        ctx.beginPath();
        ctx.ellipse(sx, sy, o.radius * 1.6, o.radius * 0.3, 0.3, 0, Math.PI * 2);
        ctx.stroke();
        ctx.globalAlpha = o.opacity;
      }
    } else if (o.kind === 'nebula') {
      // Soft glowing cloud with multiple circles
      for (let i = 0; i < 5; i++) {
        const angle = (i / 5) * Math.PI * 2 + o.seed;
        const offX = Math.cos(angle) * o.radius * 0.3;
        const offY = Math.sin(angle) * o.radius * 0.3;
        const r = o.radius * (0.5 + Math.sin(o.seed + i) * 0.3);
        const grad = ctx.createRadialGradient(sx + offX, sy + offY, 0, sx + offX, sy + offY, r);
        grad.addColorStop(0, `hsla(${o.hue + i * 20}, 70%, 50%, 0.15)`);
        grad.addColorStop(1, `hsla(${o.hue + i * 20}, 70%, 30%, 0)`);
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(sx + offX, sy + offY, r, 0, Math.PI * 2);
        ctx.fill();
      }
    } else if (o.kind === 'asteroid') {
      // Irregular rocky shape (rotation updated in updateBgObjects)
      ctx.fillStyle = '#665544';
      ctx.beginPath();
      const n = o.points.length;
      for (let i = 0; i < n; i++) {
        const a = o.rotation + (i / n) * Math.PI * 2;
        const r = o.radius * o.points[i];
        const px = sx + Math.cos(a) * r;
        const py = sy + Math.sin(a) * r;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fill();
      // Highlight edge
      ctx.strokeStyle = '#887766';
      ctx.lineWidth = 0.5;
      ctx.stroke();
    } else if (o.kind === 'comet') {
      // Glowing head
      const grad = ctx.createRadialGradient(sx, sy, 0, sx, sy, o.radius * 2);
      grad.addColorStop(0, 'rgba(200, 220, 255, 0.8)');
      grad.addColorStop(1, 'rgba(100, 150, 255, 0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(sx, sy, o.radius * 2, 0, Math.PI * 2);
      ctx.fill();
      // Core
      ctx.fillStyle = '#ddeeff';
      ctx.beginPath();
      ctx.arc(sx, sy, o.radius * 0.6, 0, Math.PI * 2);
      ctx.fill();
      // Tail
      const tailX = sx - Math.sin(o.angle) * o.tailLen;
      const tailY = sy - o.tailLen;
      const tGrad = ctx.createLinearGradient(sx, sy, tailX, tailY);
      tGrad.addColorStop(0, 'rgba(150, 180, 255, 0.4)');
      tGrad.addColorStop(1, 'rgba(100, 140, 255, 0)');
      ctx.strokeStyle = tGrad;
      ctx.lineWidth = o.radius * 1.5;
      ctx.lineCap = 'round';
      ctx.beginPath();
      ctx.moveTo(sx, sy);
      ctx.lineTo(tailX, tailY);
      ctx.stroke();
    }
  }
  ctx.restore();
}

// --- Enemy types ---
const ENEMY_TYPES = [
  {
    name: 'Fish', limbs: 0, color: '#4488ff', width: 44, height: 22,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y, w / 2, h / 2, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y);
      ctx.lineTo(x + w / 2 + 10, y - 8);
      ctx.lineTo(x + w / 2 + 10, y + 8);
      ctx.closePath();
      ctx.fill();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - w / 4, y - 2, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x - w / 4, y - 2, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Bird', limbs: 2, color: '#ff6644', width: 40, height: 28,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y, w / 3, h / 3, 0, 0, Math.PI * 2);
      ctx.fill();
      const wingFlap = Math.sin(t * 8) * 6;
      ctx.beginPath();
      ctx.moveTo(x - 5, y);
      ctx.lineTo(x - w / 2 - 4, y - 10 + wingFlap);
      ctx.lineTo(x - w / 4, y + 2);
      ctx.closePath();
      ctx.fill();
      ctx.beginPath();
      ctx.moveTo(x + 5, y);
      ctx.lineTo(x + w / 2 + 4, y - 10 + wingFlap);
      ctx.lineTo(x + w / 4, y + 2);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x - 4, y + h / 3);
      ctx.lineTo(x - 6, y + h / 2 + 4);
      ctx.moveTo(x + 4, y + h / 3);
      ctx.lineTo(x + 6, y + h / 2 + 4);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x, y - 3, 2.5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x, y - 3, 1.2, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Human', limbs: 4, color: '#ffaa33', width: 28, height: 44,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(x, y - h / 3, 7, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x, y - h / 3 + 7);
      ctx.lineTo(x, y + 4);
      ctx.stroke();
      const armSwing = Math.sin(t * 4) * 8;
      ctx.beginPath();
      ctx.moveTo(x, y - h / 6);
      ctx.lineTo(x - 12, y - h / 6 + 10 + armSwing);
      ctx.moveTo(x, y - h / 6);
      ctx.lineTo(x + 12, y - h / 6 + 10 - armSwing);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(x, y + 4);
      ctx.lineTo(x - 8, y + h / 2.5);
      ctx.moveTo(x, y + 4);
      ctx.lineTo(x + 8, y + h / 2.5);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 2.5, y - h / 3 - 1, 1.5, 0, Math.PI * 2);
      ctx.arc(x + 2.5, y - h / 3 - 1, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Insect', limbs: 6, color: '#66ff44', width: 32, height: 24,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x - 6, y, 6, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 4, y, 8, 6, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      const legWiggle = Math.sin(t * 10) * 3;
      for (let i = 0; i < 3; i++) {
        const lx = x - 4 + i * 6;
        ctx.beginPath();
        ctx.moveTo(lx, y + 4);
        ctx.lineTo(lx - 6, y + 12 + (i % 2 === 0 ? legWiggle : -legWiggle));
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(lx, y + 4);
        ctx.lineTo(lx + 6, y + 12 + (i % 2 === 0 ? -legWiggle : legWiggle));
        ctx.stroke();
      }
      ctx.beginPath();
      ctx.moveTo(x - 8, y - 4);
      ctx.lineTo(x - 14, y - 12);
      ctx.moveTo(x - 4, y - 4);
      ctx.lineTo(x - 8, y - 14);
      ctx.stroke();
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - 9, y - 2, 2, 0, Math.PI * 2);
      ctx.arc(x - 4, y - 2, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  },
  {
    name: 'Spider', limbs: 8, color: '#cc44ff', width: 38, height: 34,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x, y + 8, 6, 8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 1.5;
      const legAnim = Math.sin(t * 8) * 4;
      for (let i = 0; i < 4; i++) {
        const angle = (-0.8 + i * 0.45);
        const knee = 12;
        const lkx = x - Math.cos(angle) * knee;
        const lky = y + Math.sin(angle) * knee + (i % 2 === 0 ? legAnim : -legAnim);
        ctx.beginPath();
        ctx.moveTo(x - 4, y - 2 + i * 4);
        ctx.lineTo(lkx - 4, lky);
        ctx.lineTo(lkx - 8, lky + 8);
        ctx.stroke();
        const rkx = x + Math.cos(angle) * knee;
        const rky = y + Math.sin(angle) * knee + (i % 2 === 0 ? -legAnim : legAnim);
        ctx.beginPath();
        ctx.moveTo(x + 4, y - 2 + i * 4);
        ctx.lineTo(rkx + 4, rky);
        ctx.lineTo(rkx + 8, rky + 8);
        ctx.stroke();
      }
      ctx.fillStyle = '#f44';
      for (let i = 0; i < 4; i++) {
        ctx.beginPath();
        ctx.arc(x - 4 + (i % 2) * 8, y - 4 + Math.floor(i / 2) * 4, 1.5, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  },
  {
    name: 'Octopus', limbs: 8, color: '#ff44aa', width: 40, height: 42,
    draw(x, y, w, h, t) {
      ctx.fillStyle = this.color;
      ctx.beginPath();
      ctx.ellipse(x, y - 6, 14, 12, 0, Math.PI, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x, y - 2, 14, 6, 0, 0, Math.PI);
      ctx.fill();
      ctx.strokeStyle = this.color;
      ctx.lineWidth = 2.5;
      ctx.lineCap = 'round';
      for (let i = 0; i < 8; i++) {
        const baseX = x - 12 + i * 3.4;
        const tentLen = 16;
        const wv = Math.sin(t * 4 + i * 0.8) * 5;
        const wv2 = Math.cos(t * 3 + i * 1.2) * 3;
        ctx.beginPath();
        ctx.moveTo(baseX, y + 2);
        ctx.quadraticCurveTo(baseX + wv, y + 10, baseX + wv2, y + tentLen + 4);
        ctx.stroke();
      }
      ctx.lineCap = 'butt';
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.ellipse(x - 5, y - 6, 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(x + 5, y - 6, 4, 5, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(x - 5, y - 5, 2, 0, Math.PI * 2);
      ctx.arc(x + 5, y - 5, 2, 0, Math.PI * 2);
      ctx.fill();
    }
  }
];

// --- Player ship ---
function updatePlayer(dt) {
  // Keyboard movement
  let moveDirX = 0;
  let moveDirY = 0;
  if (keysDown.has('ArrowLeft'))  moveDirX -= 1;
  if (keysDown.has('ArrowRight')) moveDirX += 1;
  if (keysDown.has('ArrowUp'))    moveDirY -= 1;
  if (keysDown.has('ArrowDown'))  moveDirY += 1;

  if (moveDirX !== 0 || moveDirY !== 0) {
    playerX += moveDirX * PLAYER_SPEED * dt * 60;
    playerY += moveDirY * PLAYER_SPEED * dt * 60;
    playerTargetX = null; // keyboard overrides touch
    playerTargetY = null;
  }

  // Touch-to-move: glide toward tap position
  if (playerTargetX !== null) {
    const dx = playerTargetX - playerX;
    if (Math.abs(dx) < 2) {
      playerX = playerTargetX;
      playerTargetX = null;
    } else {
      playerX += Math.sign(dx) * Math.min(Math.abs(dx), PLAYER_SPEED * 1.5 * dt * 60);
    }
  }
  if (playerTargetY !== null) {
    const dy = playerTargetY - playerY;
    if (Math.abs(dy) < 2) {
      playerY = playerTargetY;
      playerTargetY = null;
    } else {
      playerY += Math.sign(dy) * Math.min(Math.abs(dy), PLAYER_SPEED * 1.5 * dt * 60);
    }
  }

  // Clamp to screen bounds
  const margin = 16;
  const topLimit = H() * 0.5;  // can't go above halfway
  const bottomLimit = H() - 20;
  playerX = Math.max(margin, Math.min(W() - margin, playerX));
  playerY = Math.max(topLimit, Math.min(bottomLimit, playerY));
}

function drawPlayer(t) {
  const px = playerX;
  const py = playerY;

  // Main fuselage
  ctx.fillStyle = '#0ff';
  ctx.beginPath();
  ctx.moveTo(px, py - 22);       // nose
  ctx.lineTo(px - 8, py - 4);    // left shoulder
  ctx.lineTo(px - 8, py + 12);   // left base
  ctx.lineTo(px + 8, py + 12);   // right base
  ctx.lineTo(px + 8, py - 4);    // right shoulder
  ctx.closePath();
  ctx.fill();

  // Left wing
  ctx.fillStyle = '#08cccc';
  ctx.beginPath();
  ctx.moveTo(px - 8, py - 2);
  ctx.lineTo(px - 20, py + 10);
  ctx.lineTo(px - 20, py + 14);
  ctx.lineTo(px - 8, py + 10);
  ctx.closePath();
  ctx.fill();

  // Right wing
  ctx.beginPath();
  ctx.moveTo(px + 8, py - 2);
  ctx.lineTo(px + 20, py + 10);
  ctx.lineTo(px + 20, py + 14);
  ctx.lineTo(px + 8, py + 10);
  ctx.closePath();
  ctx.fill();

  // Wing tips
  ctx.fillStyle = '#0ff';
  ctx.fillRect(px - 21, py + 8, 3, 7);
  ctx.fillRect(px + 18, py + 8, 3, 7);

  // Cockpit canopy
  ctx.fillStyle = '#aef';
  ctx.beginPath();
  ctx.moveTo(px, py - 16);
  ctx.lineTo(px - 4, py - 4);
  ctx.lineTo(px + 4, py - 4);
  ctx.closePath();
  ctx.fill();

  // Cockpit glint
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.beginPath();
  ctx.moveTo(px - 1, py - 14);
  ctx.lineTo(px - 3, py - 6);
  ctx.lineTo(px, py - 7);
  ctx.closePath();
  ctx.fill();

  // Panel line down fuselage
  ctx.strokeStyle = 'rgba(0,0,0,0.25)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(px, py - 4);
  ctx.lineTo(px, py + 12);
  ctx.stroke();

  // Engine nacelles
  ctx.fillStyle = '#099';
  ctx.fillRect(px - 7, py + 10, 5, 4);
  ctx.fillRect(px + 2, py + 10, 5, 4);

  // Engine flames (dual)
  const flicker = Math.sin(t * 20) * 3;
  const flicker2 = Math.cos(t * 25) * 2;
  ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
  ctx.beginPath();
  ctx.moveTo(px - 7, py + 14);
  ctx.lineTo(px - 4.5, py + 22 + flicker);
  ctx.lineTo(px - 2, py + 14);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(px + 2, py + 14);
  ctx.lineTo(px + 4.5, py + 22 + flicker2);
  ctx.lineTo(px + 7, py + 14);
  ctx.closePath();
  ctx.fill();

  // Inner flame glow
  ctx.fillStyle = 'rgba(180, 255, 255, 0.7)';
  ctx.beginPath();
  ctx.moveTo(px - 6, py + 14);
  ctx.lineTo(px - 4.5, py + 18 + flicker * 0.5);
  ctx.lineTo(px - 3, py + 14);
  ctx.closePath();
  ctx.fill();
  ctx.beginPath();
  ctx.moveTo(px + 3, py + 14);
  ctx.lineTo(px + 4.5, py + 18 + flicker2 * 0.5);
  ctx.lineTo(px + 7, py + 14);
  ctx.closePath();
  ctx.fill();
}

// --- Formation helpers ---

// Get the world position of a formation slot
function getFormationSlotPos(row, col) {
  const cellW = Math.min(FORMATION_CELL_W, (W() - 40) / Math.max(formationCols, 1));
  const totalW = formationCols * cellW;
  const centerX = W() / 2 + formationX;
  const startX = centerX - totalW / 2;
  const x = startX + col * cellW + cellW / 2;
  const y = FORMATION_TOP_MARGIN + row * FORMATION_CELL_H + FORMATION_CELL_H / 2;
  return { x, y };
}

// Build the enemy grid for a wave
function buildFormation() {
  enemies = [];
  entryQueue = [];
  entryActive = [];

  // Determine how many rows/cols to fill based on wave
  const rows = Math.min(4, 2 + Math.floor(wave / 2));
  const cols = Math.min(8, 4 + Math.min(4, wave));
  formationRows = rows;
  formationCols = cols;

  // Pick enemy types for each row (variety increases with wave)
  const availableTypes = ENEMY_TYPES.slice();

  // Build the formation - queue them for entry animation
  for (let r = 0; r < rows; r++) {
    const rowType = availableTypes[Math.floor(Math.random() * availableTypes.length)];
    for (let c = 0; c < cols; c++) {
      let type = rowType;
      if (Math.random() < 0.25) {
        type = availableTypes[Math.floor(Math.random() * availableTypes.length)];
      }

      const enemy = {
        row: r,
        col: c,
        type,
        hit: false,
        flash: 0,
        removeTimer: undefined,
        state: 'entering',
        diveX: 0,
        diveY: 0,
        divePhase: 0,
        diveStartX: 0,
        diveStartY: 0,
        spawnTime: performance.now() / 1000,
        entryX: 0,
        entryY: -40,
        entryProgress: 0,
      };
      entryQueue.push(enemy);
    }
  }

  // Stagger the entry - groups fly in from top
  entryQueue.sort((a, b) => a.row !== b.row ? a.row - b.row : a.col - b.col);

  // Reset formation position
  formationX = 0;
  formationDir = 1;
  formationSpeed = FORMATION_H_SPEED_BASE + wave * FORMATION_H_SPEED_WAVE;
  diveTimer = 3000; // grace period before first dive
  waveCleared = false;
}

// Launch next batch from entry queue
let entryBatchTimer = 0;
const ENTRY_BATCH_SIZE = 4;
const ENTRY_BATCH_DELAY = 300; // ms between batches

function updateEntryQueue(dt) {
  // Launch batches from the queue
  entryBatchTimer -= dt * 1000;
  if (entryBatchTimer <= 0 && entryQueue.length > 0) {
    const batch = entryQueue.splice(0, ENTRY_BATCH_SIZE);
    for (const e of batch) {
      // Start from top of screen, slightly spread
      const targetPos = getFormationSlotPos(e.row, e.col);
      e.entryX = W() / 2 + (Math.random() - 0.5) * 100;
      e.entryY = -30 - Math.random() * 40;
      e.entryProgress = 0;
      entryActive.push(e);
      enemies.push(e);
    }
    entryBatchTimer = ENTRY_BATCH_DELAY;
  }

  // Animate active entries
  for (let i = entryActive.length - 1; i >= 0; i--) {
    const e = entryActive[i];
    e.entryProgress += dt * 2.5; // speed of entry animation
    if (e.entryProgress >= 1) {
      e.entryProgress = 1;
      e.state = 'formation';
      entryActive.splice(i, 1);
    }
  }
}

// --- Formation movement ---
function updateFormation(dt) {
  // Move the formation side to side
  formationX += formationSpeed * formationDir * dt * 60;

  // Compute actual bounds from living formation/entering enemies
  let minX = Infinity, maxX = -Infinity;
  for (const e of enemies) {
    if (e.hit || (e.state !== 'formation' && e.state !== 'entering')) continue;
    const pos = getFormationSlotPos(e.row, e.col);
    const hw = (e.type.width / 2) + 8;
    minX = Math.min(minX, pos.x - hw);
    maxX = Math.max(maxX, pos.x + hw);
  }

  if (minX === Infinity) return; // no formation enemies

  const margin = 8;
  if (maxX > W() - margin && formationDir > 0) {
    formationDir = -1;
    formationX -= (maxX - (W() - margin)); // snap back in-bounds
  } else if (minX < margin && formationDir < 0) {
    formationDir = 1;
    formationX += (margin - minX); // snap back in-bounds
  }
}

// --- Dive attacks ---
function updateDiveAttacks(dt) {
  diveTimer -= dt * 1000;

  const formationEnemies = enemies.filter(e => !e.hit && e.state === 'formation');
  if (formationEnemies.length === 0) return;

  if (diveTimer <= 0) {
    // Launch wave-number of enemies at once
    const count = Math.min(wave, formationEnemies.length);
    // Shuffle to pick random divers
    const shuffled = formationEnemies.sort(() => Math.random() - 0.5);
    for (let d = 0; d < count; d++) {
      const diver = shuffled[d];
      const pos = getFormationSlotPos(diver.row, diver.col);

      diver.state = 'diving';
      diver.divePhase = 0;
      diver.diveStartX = pos.x;
      diver.diveStartY = pos.y;
      diver.diveTargetX = playerX + (Math.random() - 0.5) * 60;
      diver.diveTargetY = H() + 60;
    }

    const interval = Math.max(DIVE_INTERVAL_MIN,
      DIVE_INTERVAL_BASE - wave * DIVE_INTERVAL_WAVE_REDUCTION);
    diveTimer = interval + Math.random() * 800;
  }
}

function updateDivingEnemies(dt) {
  if (!gameRunning) return;
  const diveSpeed = DIVE_SPEED_BASE + wave * DIVE_SPEED_WAVE;

  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.state !== 'diving' && e.state !== 'returning') continue;
    if (e.hit) continue;

    if (e.state === 'diving') {
      e.divePhase += dt * diveSpeed;

      // Gently steer toward player's current X (tracking factor)
      const trackStrength = 1.5 * dt;
      e.diveTargetX += (playerX - e.diveTargetX) * trackStrength;

      // Swooping curve path
      const t = e.divePhase;
      const wobble = Math.sin(t * 4) * 30;

      // Interpolate with curve
      e.diveX = e.diveStartX + (e.diveTargetX - e.diveStartX) * t + wobble;
      e.diveY = e.diveStartY + (e.diveTargetY - e.diveStartY) * t;

      // Check collision with player ship
      const dx = Math.abs(e.diveX - playerX);
      const dy = Math.abs(e.diveY - playerY);
      const hitW = (e.type.width + 40) / 2;  // enemy half-width + ship half-width
      const hitH = (e.type.height + 36) / 2;
      if (dx < hitW && dy < hitH) {
        // Hit the player
        lives--;
        updateHUD();
        screenShake(12, 0.4);
        e.hit = true;
        e.removeTimer = 0.05;
        spawnExplosion(e.diveX, e.diveY, e.type.color);
        spawnExplosion(playerX, playerY, '#0ff');  // player ship explosion
        if (lives <= 0) {
          gameOver();
          return;
        }
        continue;
      }

      if (e.divePhase >= 1) {
        // Missed the player - return to formation
        e.state = 'returning';
        e.divePhase = 0;
        const target = getFormationSlotPos(e.row, e.col);
        e.diveStartX = e.diveX;
        e.diveStartY = -40; // come back from top
        e.diveTargetX = target.x;
        e.diveTargetY = target.y;
      }
    } else if (e.state === 'returning') {
      e.divePhase += dt * 2.0;
      const t = Math.min(1, e.divePhase);

      // Smooth return arc from top
      const target = getFormationSlotPos(e.row, e.col);
      e.diveX = e.diveStartX + (target.x - e.diveStartX) * t;
      e.diveY = e.diveStartY + (target.y - e.diveStartY) * t;

      if (e.divePhase >= 1) {
        e.state = 'formation';
      }
    }
  }
}

// --- Get world position for any enemy ---
function getEnemyPos(e) {
  if (e.state === 'entering') {
    const target = getFormationSlotPos(e.row, e.col);
    const t = e.entryProgress;
    // Ease-out curve
    const ease = 1 - (1 - t) * (1 - t);
    return {
      x: e.entryX + (target.x - e.entryX) * ease,
      y: e.entryY + (target.y - e.entryY) * ease
    };
  } else if (e.state === 'formation') {
    return getFormationSlotPos(e.row, e.col);
  } else if (e.state === 'diving' || e.state === 'returning') {
    return { x: e.diveX, y: e.diveY };
  }
  return getFormationSlotPos(e.row, e.col);
}

// --- Enemy update ---
function updateEnemies(dt) {
  for (let i = enemies.length - 1; i >= 0; i--) {
    const e = enemies[i];
    if (e.hit) {
      if (e.removeTimer !== undefined) {
        e.removeTimer -= dt;
        if (e.removeTimer <= 0) {
          enemies.splice(i, 1);
        }
      }
      continue;
    }
    if (e.flash > 0) e.flash -= dt * 4;
  }
}

function drawEnemies(t) {
  for (const e of enemies) {
    if (e.hit) continue;
    const pos = getEnemyPos(e);
    // Skip off-screen enemies to prevent ghost trails
    if (pos.y > H() + 5 || pos.y < -60 || pos.x < -60 || pos.x > W() + 60) continue;
    ctx.save();
    if (e.flash > 0) {
      ctx.globalAlpha = 0.5 + 0.5 * Math.sin(e.flash * 20);
    }
    // Slight visual indication of diving enemies
    if (e.state === 'diving') {
      ctx.shadowColor = '#f44';
      ctx.shadowBlur = 10;
    }
    e.type.draw(pos.x, pos.y, e.type.width, e.type.height, t);

    // Limb count label
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 13px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(e.type.limbs, pos.x, pos.y - e.type.height / 2 - 6);
    ctx.restore();
  }
}

// --- Missiles ---
function fireMissile(targetLimbs) {
  // Collect enemies already targeted by in-flight missiles
  const alreadyTargeted = new Set(missiles.filter(m => m.alive).map(m => m.target));

  const matching = enemies
    .filter(e => e.type.limbs === targetLimbs && !e.hit)
    .map(e => ({ enemy: e, pos: getEnemyPos(e) }))
    .sort((a, b) => b.pos.y - a.pos.y);

  if (matching.length === 0) return false;

  // Prefer enemies without a missile already in flight, but allow duplicates
  const untargeted = matching.filter(m => !alreadyTargeted.has(m.enemy));
  const target = (untargeted.length > 0 ? untargeted[0] : matching[0]).enemy;
  const px = playerX;

  missiles.push({
    x: px, y: playerY - 22,
    target,
    trail: [],
    alive: true,
    age: 0
  });

  return true;
}

function updateMissiles(dt) {
  for (let i = missiles.length - 1; i >= 0; i--) {
    const m = missiles[i];
    if (!m.alive) { missiles.splice(i, 1); continue; }

    const t = m.target;
    if (t.hit || enemies.indexOf(t) === -1) {
      // Target destroyed — self destruct
      spawnExplosion(m.x, m.y, '#ffaa44');
      missiles.splice(i, 1);
      continue;
    }

    const tpos = getEnemyPos(t);
    const dx = tpos.x - m.x;
    const dy = tpos.y - m.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist < 14) {
      t.hit = true;
      t.removeTimer = 0.05;
      m.alive = false;
      spawnExplosion(tpos.x, tpos.y, t.type.color);
      score += 10 + wave * 5;
      // Bonus for hitting a diving enemy
      if (t.state === 'diving') {
        score += 20;
      }
      updateHUD();
      missiles.splice(i, 1);
      continue;
    }

    const speed = MISSILE_SPEED * dt * 60;
    // Move along the direction to target
    const ndx = dx / dist;
    const ndy = dy / dist;
    m.x += ndx * speed;
    m.y += ndy * speed;

    // Serpentine offset perpendicular to travel direction
    m.age += dt;
    const serpAmp = 12;
    const serpFreq = 18;
    const serpOffset = Math.sin(m.age * serpFreq) * serpAmp * dt;
    // Perpendicular vector is (-ndy, ndx)
    m.x += -ndy * serpOffset;
    m.y += ndx * serpOffset;

    m.trail.push({ x: m.x, y: m.y, life: 1 });
    if (m.trail.length > 20) m.trail.shift();

    // Decay trail life and remove expired points
    for (let j = m.trail.length - 1; j >= 0; j--) {
      m.trail[j].life -= 0.05;
      if (m.trail[j].life <= 0) m.trail.splice(j, 1);
    }
  }
}

function drawMissiles() {
  for (const m of missiles) {
    for (let i = 0; i < m.trail.length; i++) {
      const p = m.trail[i];
      ctx.fillStyle = `rgba(255, 255, 0, ${Math.max(0, p.life) * 0.6})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, Math.max(0, 2 * p.life), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.fillStyle = '#ff0';
    ctx.shadowColor = '#ff0';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    ctx.arc(m.x, m.y, 3, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

// --- Particles / Explosions ---
function spawnExplosion(x, y, color) {
  for (let i = 0; i < 20; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 3 + 1;
    particles.push({
      x, y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      life: 1,
      color,
      size: Math.random() * 3 + 1
    });
  }
}

function updateParticles(dt) {
  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * dt * 60;
    p.y += p.vy * dt * 60;
    p.life -= dt * 2;
    if (p.life <= 0) particles.splice(i, 1);
  }
}

function drawParticles() {
  for (const p of particles) {
    ctx.globalAlpha = Math.max(0, p.life);
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, Math.max(0, p.size * p.life), 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.globalAlpha = 1;
}

// --- Starfield ---
function drawStars(dt) {
  for (const s of stars) {
    s.y += s.speed * dt * 60;
    if (s.y > 1000) { s.y = 0; s.x = Math.random() * 1000; }
    s.brightness += (Math.random() - 0.5) * 0.1;
    s.brightness = Math.max(0.2, Math.min(1, s.brightness));

    const sx = (s.x / 1000) * W();
    const sy = (s.y / 1000) * H();
    ctx.fillStyle = `rgba(255, 255, 255, ${s.brightness * 0.7})`;
    ctx.beginPath();
    ctx.arc(sx, sy, s.size, 0, Math.PI * 2);
    ctx.fill();
  }
}

// --- Screen shake ---
let shakeAmount = 0;
let shakeDuration = 0;
function screenShake(amount, duration) {
  shakeAmount = amount;
  shakeDuration = duration;
}

// --- Wave management ---
function checkWave() {
  if (waveCleared) return;

  const alive = enemies.filter(e => !e.hit);
  if (alive.length === 0 && entryQueue.length === 0 && entryActive.length === 0) {
    waveCleared = true;
    wave++;
    waveTransition = 2.5;
    updateHUD();
    // Build next formation after a brief delay
    setTimeout(() => {
      if (gameRunning) {
        buildFormation();
      }
    }, 1500);
  }
}

// --- HUD ---
function updateHUD() {
  document.getElementById('score-display').textContent = `Score: ${score}`;
  document.getElementById('wave-display').textContent = `Wave: ${wave}`;
  document.getElementById('lives-display').textContent = `Lives: ${'♥'.repeat(Math.max(0, lives))}`;
}

// --- Input handling ---
function handleDigit(digit) {
  if (!gameRunning) return;

  const num = parseInt(digit);
  if (isNaN(num)) return;

  inputBuffer = digit;
  document.getElementById('input-display').textContent = digit;

  const hit = fireMissile(num);

  const display = document.getElementById('input-display');
  display.style.color = hit ? '#0f0' : '#f44';
  setTimeout(() => {
    inputBuffer = '';
    display.textContent = '';
    display.style.color = '#ff0';
  }, 300);
}

// Desktop keyboard
document.addEventListener('keydown', (e) => {
  if (e.key >= '0' && e.key <= '9') {
    handleDigit(e.key);
  }
  if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' ||
      e.key === 'ArrowUp' || e.key === 'ArrowDown') {
    e.preventDefault();
    keysDown.add(e.key);
  }
});
document.addEventListener('keyup', (e) => {
  keysDown.delete(e.key);
});

// Touch/click to move ship on the game canvas
canvas.addEventListener('touchstart', (e) => {
  if (!gameRunning) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  const scaleY = rect.height / container.clientHeight;
  playerTargetX = (e.touches[0].clientX - rect.left) / scaleX;
  playerTargetY = (e.touches[0].clientY - rect.top) / scaleY;
});
canvas.addEventListener('touchmove', (e) => {
  if (!gameRunning) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  const scaleY = rect.height / container.clientHeight;
  playerTargetX = (e.touches[0].clientX - rect.left) / scaleX;
  playerTargetY = (e.touches[0].clientY - rect.top) / scaleY;
});
canvas.addEventListener('touchend', () => {
  // Keep gliding to last target, don't snap-clear
});
canvas.addEventListener('mousedown', (e) => {
  if (!gameRunning) return;
  const rect = canvas.getBoundingClientRect();
  const scaleX = rect.width / container.clientWidth;
  const scaleY = rect.height / container.clientHeight;
  playerTargetX = (e.clientX - rect.left) / scaleX;
  playerTargetY = (e.clientY - rect.top) / scaleY;
});

// Mobile on-screen keyboard
document.querySelectorAll('#onscreen-keyboard button').forEach(btn => {
  btn.addEventListener('touchstart', (e) => {
    e.preventDefault();
    handleDigit(btn.dataset.key);
  });
  btn.addEventListener('mousedown', (e) => {
    e.preventDefault();
    handleDigit(btn.dataset.key);
  });
});

// --- Game loop ---
function gameLoop(timestamp) {
  if (!gameRunning) return;

  try {
    const t = timestamp / 1000;
    const dt = Math.min((timestamp - lastTime) / 1000, 0.05);
    lastTime = timestamp;

    // Update
    updatePlayer(dt);
    updateEntryQueue(dt);
    updateFormation(dt);
    updateDiveAttacks(dt);
    updateDivingEnemies(dt);
    updateEnemies(dt);
    updateMissiles(dt);
    updateParticles(dt);
    updateBgObjects(dt);
    checkWave();

    // Screen shake
    let shakeX = 0, shakeY = 0;
    if (shakeDuration > 0) {
      shakeDuration -= dt;
      shakeX = (Math.random() - 0.5) * shakeAmount * 2;
      shakeY = (Math.random() - 0.5) * shakeAmount * 2;
      shakeAmount *= 0.95;
    }

    // Wave transition text
    if (waveTransition > 0) {
      waveTransition -= dt;
    }

    // Draw
    ctx.save();
    ctx.translate(shakeX, shakeY);

    ctx.fillStyle = '#0a0a2e';
    ctx.fillRect(-100, -100, W() + 200, H() + 200);

    drawStars(dt);
    drawBgObjects(t);
    drawEnemies(t);
    drawMissiles();
    drawParticles();
    drawPlayer(t);

    // Wave transition overlay
    if (waveTransition > 0) {
      const alpha = Math.min(1, waveTransition);
      ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
      ctx.font = 'bold 28px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(`Wave ${wave}`, W() / 2, H() / 2);
      ctx.font = '16px Courier New';
      ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.7})`;
      ctx.fillText('Get ready!', W() / 2, H() / 2 + 30);
    }

    ctx.restore();
  } catch (err) {
    console.error('Game loop error:', err);
  }

  requestAnimationFrame(gameLoop);
}

// --- Start / Restart ---
function startGame() {
  enemies = [];
  missiles = [];
  particles = [];
  entryQueue = [];
  entryActive = [];
  score = 0;
  wave = 1;
  lives = PLAYER_LIVES;
  inputBuffer = '';
  gameRunning = true;
  playerX = W() / 2;
  playerY = H() - 40;
  playerTargetX = null;
  playerTargetY = null;
  keysDown.clear();
  waveTransition = 2.5;
  entryBatchTimer = 0;
  document.getElementById('overlay').classList.add('hidden');
  document.getElementById('input-display').textContent = '';
  document.getElementById('final-score').textContent = '';
  updateHUD();
  lastTime = performance.now();
  buildFormation();
  requestAnimationFrame(gameLoop);
}

function gameOver() {
  // Big explosion at player position on final death
  spawnExplosion(playerX, playerY, '#0ff');
  spawnExplosion(playerX, playerY, '#fff');
  gameRunning = false;
  const overlay = document.getElementById('overlay');
  overlay.querySelector('h1').textContent = 'Game Over';
  document.getElementById('final-score').textContent = `Final Score: ${score}`;
  document.getElementById('start-btn').textContent = 'Retry';
  overlay.classList.remove('hidden');
}

// --- Start button ---
document.getElementById('start-btn').addEventListener('click', startGame);
document.getElementById('start-btn').addEventListener('touchend', (e) => {
  e.preventDefault();
  startGame();
});

// Initial HUD
updateHUD();
</script>
</body>
</html>
